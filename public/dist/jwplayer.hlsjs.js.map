{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/eventemitter3/index.js",
    "src/jwplayer.hlsjs.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n",
    "'use strict';\nvar EventEmitter = require('eventemitter3');\nvar E = module.exports = HlsProv;\nvar provider_attached = false;\n// jwplayer v8+ dropped exposing jwplayer.events\nvar jwe = {\n    JWPLAYER_MEDIA_BEFORECOMPLETE: 'beforeComplete',\n    JWPLAYER_MEDIA_BUFFER: 'bufferChange',\n    JWPLAYER_MEDIA_BUFFER_FULL: 'bufferFull',\n    JWPLAYER_MEDIA_COMPLETE: 'complete',\n    JWPLAYER_MEDIA_ERROR: 'mediaError',\n    JWPLAYER_MEDIA_LEVELS: 'levels',\n    JWPLAYER_MEDIA_LEVEL_CHANGED: 'levelsChanged',\n    JWPLAYER_MEDIA_META: 'meta',\n    JWPLAYER_MEDIA_SEEK: 'seek',\n    JWPLAYER_MEDIA_SEEKED: 'seeked',\n    JWPLAYER_MEDIA_TIME: 'time',\n    JWPLAYER_MEDIA_TYPE: 'mediaType',\n    JWPLAYER_PLAYER_STATE: 'state',\n    JWPLAYER_PROVIDER_FIRST_FRAME: 'providerFirstFrame',\n};\n\n// XXX arik: protect against exceptions in api. currently jwplayer will be\n// stuck + add test\nfunction HlsProv(id, _playerConfig, mediaElement){\n    var jwplayer = E.jwplayer||window.jwplayer, Hls = E.Hls||window.Hls;\n    var jw = id && jwplayer(id);\n    console.log('init hola/hls provider v'+E.VERSION+' hls v'+Hls.version+\n        (E.version ? ' hap v'+E.version : ''));\n    jw.provider = this;\n    function empty_fn(name){ return function(){}; }\n    var _this = this;\n    this.hls_restore_pos = function(){\n        var new_pos = this.hls_queued.seek;\n        var old_pos = video.currentTime;\n        if (hls.streamController.state == 'STOPPED')\n        {\n            // XXX pavelki: hack to use our start position\n            hls.streamController.startPosition = 0;\n            hls.startLoad(new_pos||0);\n        }\n        if (!new_pos)\n            return;\n        this._in_seek = true;\n        video.currentTime = new_pos;\n        this.trigger(jwe.JWPLAYER_MEDIA_SEEK, {position: old_pos,\n            offset: new_pos});\n        // XXX pavelki: hack to override W3 algorithm of media\n        // seeking: when video element has HAVE_NOTHING state,\n        // seeking event doesn't fire and loading doesn't start\n        if (!video.readyState)\n            video.dispatchEvent(new Event('seeking'));\n        this.hls_queued.seek = 0;\n    };\n    function check_playback_started(video){\n        if (video.paused)\n            return void hls_log('video play refused');\n        function rm_listeners(){\n            video.removeEventListener('playing', listener);\n            video.removeEventListener('pause', listener);\n            video.removeEventListener('abort', listener);\n            video.removeEventListener('error', listener);\n        }\n        function listener(e){\n            rm_listeners();\n            if (e.type!='playing')\n                hls_log('play() was interrupted by a \"'+e.type+'\" event');\n        }\n        video.addEventListener('playing', listener);\n        video.addEventListener('abort', listener);\n        video.addEventListener('error', listener);\n        video.addEventListener('pause', listener);\n    }\n    function video_play(){\n        var promise = video.play()||check_playback_started(video);\n        if (promise && promise.catch)\n        {\n            promise.catch(function(err){\n                hls_log('video_play failed with '+err);\n                console.warn(err);\n                // user gesture required to start playback\n                if (err.name=='NotAllowedError' &&\n                    video.hasAttribute('jw-gesture-required'))\n                {\n                    _this.trigger('autoplayFailed');\n                    video.setAttribute('autoplay-failed', 'failed');\n                }\n            });\n        }\n        else if (video.hasAttribute('jw-gesture-required'))\n        {\n            // autoplay isn't supported in older versions of Safari (<10)\n            // and Chrome (<53)\n            _this.trigger('autoplayFailed');\n            video.setAttribute('autoplay-failed', 'failed');\n        }\n    }\n    function hls_log(msg){\n        var dbg;\n        if (dbg = hls_params.debug)\n            dbg.log(msg);\n    }\n    function hls_play(){\n        hls_log('hls_play state: '+_this.hls_state+' att:'+_this.attached);\n        if (!(_this.hls_queued.play = _this.hls_state!='ready') &&\n            _this.attached)\n        {\n            _this.hls_restore_pos();\n            video_play();\n        }\n    }\n    function hls_load(src){\n        if (!src)\n            return;\n        if (_this.hls_state=='ready')\n            _this.hls_state = 'idle';\n        if (_this.level_cb)\n            hls.off(Hls.Events.LEVEL_LOADED, _this.level_cb);\n        _this.level_cb = function(){\n            hls_log('hls play queued on level_cb:'+_this.hls_queued.play);\n            hls.off(Hls.Events.LEVEL_LOADED, _this.level_cb);\n            _this.level_cb = undefined;\n            _this.hls_state = 'ready';\n            if (_this.hls_queued.play)\n                hls_play();\n            _this.trigger(jwe.JWPLAYER_MEDIA_BUFFER_FULL);\n        };\n        hls.on(Hls.Events.LEVEL_LOADED, _this.level_cb);\n        hls.loadSource(src);\n        if (!hls.media)\n            _this.attachMedia();\n    }\n    function on_video_src_change(video, allow_cb){\n        var o = video;\n        for (; o && !o.hasOwnProperty('src'); o = Object.getPrototypeOf(o));\n        if (!o)\n            return;\n        var prop = Object.getOwnPropertyDescriptor(o, 'src');\n        // XXX volodymyr: some browsers (e.g. safari9) may lock access to src,\n        // solution copied from polyfill.video_source_access in html5.js\n        if (!prop.get && !prop.set)\n        {\n            prop.get = function(){\n                var src = video.getAttribute('src');\n                return src!=null ? src : '';\n            };\n            prop.set = function(s){\n                var el = document.createElement('source');\n                el.src = s||''; // will convert relative path into absolute uri\n                video.setAttribute('src', el.src);\n            };\n        }\n        Object.defineProperty(video, 'src', {\n            configurable: true,\n            enumerable: false,\n            set: function(src){\n                if (allow_cb(prop.get.call(video), src))\n                    prop.set.call(video, src);\n            },\n            get: prop.get,\n        });\n    }\n    function get_default_src(sources){\n        return sources &&\n            sources.find(function(s){ return s.default; }) || sources[0];\n    }\n    function _log(method, message){\n        if (_this.hls.holaLog && _this.hls.holaLog[method])\n            _this.hls.holaLog[method].call(_this.hls.holaLog, message);\n    }\n    // XXX marka: jwplayer inherits provider from DefaultProvider, so it will\n    // override our inheritance from EventEmitter, do it manually\n    this.events = new EventEmitter();\n    this.addEventListener = this.on = this.events.on.bind(this.events);\n    this.once = this.events.once.bind(this.events);\n    this.removeEventListener = this.off = this.events.off.bind(this.events);\n    this.trigger = this.emit = function(e){\n        if (!_this.attached && !_this.before_complete)\n            return;\n        var args = [].slice.call(arguments);\n        _this.events.emit.apply(this.events, args);\n        if (e!='all')\n        {\n            args.unshift('all');\n            _this.events.emit.apply(this.events, args);\n        }\n    };\n    this.removeAllListeners = function(e){\n        this.events.removeAllListeners(e); };\n    this.hls_queued = {play: false, seek: 0};\n    this.attached = true;\n    this.hls_state = 'idle';\n    this.is_mobile = function(){\n        var ios, and, ua = navigator.userAgent;\n        if ((ios = /iP(hone|ad|od)/i.test(ua)) || (and = /Android/i.test(ua)))\n            return {is_ios: ios, is_android: and};\n    };\n    this.supports_captions = function(){\n        var ua = navigator.userAgent;\n        return /(iPhone|iPad|iPod|iPod touch);.*?OS/.test(ua)\n            || / (Chrome|Version)\\/\\d+(\\.\\d+)+.* Safari\\/\\d+(\\.\\d+)+/.test(ua)\n            || /Firefox\\/(\\d+(?:\\.\\d+)+)/.test(ua);\n    };\n    var video = mediaElement;\n    if (!video) {\n        var element = document.getElementById(id);\n        video = element ? element.querySelector('video') : undefined;\n    }\n    var hls, container;\n    var try_play, can_play, _is_mobile = this.is_mobile();\n    var visual_quality = {reason: 'initial choice', mode: 'auto'};\n    if (!video)\n    {\n        video = document.createElement('video');\n        if (_is_mobile)\n            video.setAttribute('jw-gesture-required', '');\n    }\n    this.video = video;\n    video.className = 'jw-video jw-reset';\n    // XXX marka: mark html5 element to skip autodetection of dm/hls\n    video.hola_dm_hls_attached = true;\n    // XXX pavelki: hack to override ozee's wrong src set\n    on_video_src_change(video, function(from, to){ return to!=from+'?'; });\n    var hls_params = E.hls_params||{}, hola_log;\n    this.ad_count = 0;\n    if (jw)\n    {\n        jw.on('captionsList', caption_track);\n        jw.on('captionsChanged', caption_track);\n        // XXX pavelki: counters for ad, need to make loading deferred\n        jw.on('adImpression', function(){\n            _this.ad_count++;\n        });\n        jw.on('adComplete', function(){ _this.ad_count--; });\n        jw.on('adSkipped', function(){ _this.ad_count--; });\n        Object.assign(hls_params, jw.hola_config);\n        if (hls_params.debug!='undefined')\n        {\n            hola_log = hls_params.debug;\n            delete hls_params.debug;\n        }\n    }\n    hls_params.debug = {};\n    ['debug', 'info', 'log', 'warn','error'].forEach(function(method){\n        hls_params.debug[method] = _log.bind(null, method); });\n    this.hls = hls = new Hls(hls_params);\n    hls.holaLog = hola_log;\n    if (jw)\n        jw.hls = hls;\n    var _buffered, _duration, _position;\n    function caption_track(cc){\n        if (!_this.renderNatively)\n            return;\n        var tracks = video.textTracks, new_id = cc.tracks[cc.track].id;\n        for (var i=0; i<tracks.length; i++)\n            tracks[i].mode = tracks[i]._id==new_id ? 'showing' : 'hidden';\n    }\n    function get_seekable_end(){\n        var i, end, len = video.seekable ? video.seekable.length : 0;\n        for (end = 0, i = 0; i<len; i++)\n            end = Math.max(end, video.seekable.end(i));\n        return end;\n    }\n    function get_duration(){\n        var duration = video.duration, end = get_seekable_end();\n        if (duration==Infinity && end)\n        {\n            var seekable_dur = end-video.seekable.start(0);\n            if (seekable_dur!=Infinity && seekable_dur>120)\n                duration = -seekable_dur;\n        }\n        return duration;\n    }\n    function get_duration_inf(){\n        return is_live() ? 1/0 : get_duration();\n    }\n    function is_live(){\n        var live, levels;\n        try {\n            if (!(levels = hls.streamController.levels))\n                return;\n            var loaded_lvl = levels.find(function(lvl){ return lvl.details; });\n            live = loaded_lvl && !!loaded_lvl.details.live;\n        } catch(e){ hls_log('is_live failed with '+e); }\n        return live;\n    }\n    function get_buffered(){\n        var buf = video.buffered, dur = video.duration;\n        if (!buf || !buf.length || dur<=0 || dur==Infinity)\n            return 0;\n        return Math.min(buf.end(buf.length-1)/dur, 1.0);\n    }\n    function set_buffered(buffered, pos, duration){\n        if (buffered==_buffered && duration==_duration)\n            return;\n        _buffered = buffered;\n        _this.trigger(jwe.JWPLAYER_MEDIA_BUFFER, {bufferPercent: buffered*100,\n            position: pos, duration: get_duration_inf()});\n    }\n    function playback_complete(){\n        _this.setState('complete');\n        _this.trigger(jwe.JWPLAYER_MEDIA_COMPLETE);\n        _this.before_complete = false;\n    }\n    var video_listeners = {\n        durationchange: function(){\n            _duration = get_duration();\n            set_buffered(get_buffered(), _position, _duration);\n        },\n        ended: function(){\n            if (_this.state=='idle' || _this.state=='complete')\n                return;\n            _this.before_complete = true;\n            _this.trigger(jwe.JWPLAYER_MEDIA_BEFORECOMPLETE);\n            if (_this.attached)\n                playback_complete();\n        },\n        error: function(){\n            _this.trigger(jwe.JWPLAYER_MEDIA_ERROR, {\n                message: 'Error loading media: File could not be played'});\n        },\n        loadstart: function(){ video.setAttribute('jw-loaded', 'started'); },\n        loadeddata: function(){\n            video.setAttribute('jw-loaded', 'data');\n            if (!_this.supports_captions())\n                return;\n            video.textTracks.onaddtrack = function(){\n                _this.renderNatively = true;\n                _this.trigger('subtitlesTracks', {tracks: video.textTracks});\n            };\n            // XXX pavelki: add checking of playlist\n            if (video.textTracks.length)\n                video.textTracks.onaddtrack();\n            _this.trigger(jwe.JWPLAYER_MEDIA_TYPE, {mediaType: video.videoHeight ?\n                'video' : 'audio'});\n        },\n        loadedmetadata: function(){\n            if (video.muted)\n            {\n                video.muted = false;\n                video.muted = true;\n            }\n            video.setAttribute('jw-loaded', 'meta');\n            _duration = get_duration();\n            _this.trigger(jwe.JWPLAYER_MEDIA_META, {duration:\n                get_duration_inf(), height: video.videoHeight,\n                width: video.videoWidth});\n        },\n        canplay: function(){\n            can_play = true;\n            _this.trigger(jwe.JWPLAYER_MEDIA_BUFFER_FULL);\n        },\n        playing: function(){\n            _this.setState('playing');\n            if (!video.hasAttribute('jw-played'))\n                video.setAttribute('jw-played', '');\n            if (video.hasAttribute('jw-gesture-required'))\n            {\n                video.removeAttribute('jw-gesture-required');\n                video.removeAttribute('autoplay-failed');\n            }\n            _this.trigger(jwe.JWPLAYER_PROVIDER_FIRST_FRAME, {});\n        },\n        pause: function(){\n            if (_this.state=='complete' || video.currentTime==video.duration)\n                return;\n            _this.setState('paused');\n        },\n        seeking: function(){\n            if (!_this._in_seek)\n            {\n                _this._in_seek = true;\n                _this.trigger(jwe.JWPLAYER_MEDIA_SEEK, {position: _position,\n                    offset: video.currentTime});\n            }\n        },\n        seeked: function(){\n            _this._in_seek = false;\n            _this.trigger(jwe.JWPLAYER_MEDIA_SEEKED);\n        },\n        progress: function(){\n            set_buffered(get_buffered(), _position, _duration); },\n        timeupdate: function(){\n            _duration = get_duration();\n            _position = _duration<0 ? -(get_seekable_end()-video.currentTime) :\n                video.currentTime;\n            set_buffered(get_buffered(), _position, _duration);\n            if (_this.state=='playing')\n            {\n                _this.trigger(jwe.JWPLAYER_MEDIA_TIME, {position: _position,\n                    duration: get_duration_inf()});\n            }\n        },\n    };\n    function wrap_gen(e){\n        return function(){\n            if (!_this.attached)\n                return;\n            video_listeners[e]();\n        };\n    }\n    for (var e in video_listeners)\n        video.addEventListener(e, wrap_gen(e), false);\n    function scaled_number(num){\n        if (num===undefined)\n            return '';\n        if (!num)\n            return '0';\n        var k = 1024;\n        var sizes = ['', 'K', 'M', 'G', 'T', 'P'];\n        var i = Math.floor(Math.log(num)/Math.log(k));\n        num /= Math.pow(k, i);\n        if (num<0.001)\n            return '0';\n        if (num>=k-1)\n            num = Math.trunc(num);\n        var str = num.toFixed(num<1 ? 3 : num<10 ? 2 : num<100 ? 1 : 0);\n        return str.replace(/\\.0*$/, '')+sizes[i];\n    }\n    // XXX yurij: duplicate from videojs5-hlsjs to avoid deps\n    function level_label(level){\n        if (level.height)\n            return level.height+'p';\n        if (level.width)\n            return Math.round(level.width*9/16)+'p';\n        if (level.bitrate)\n            return scaled_number(level.bitrate)+'bps';\n        return 0;\n    }\n    function get_levels(){\n        var levels = hls.levels||[], res = [];\n        // level 0 mimics native jw's hls provider behavior\n        if (levels.length>1)\n            res.push({label: 'Auto'});\n        levels.forEach(function(level){\n            res.push({bitrate: level.bitrate, height: level.height,\n                label: level_label(level), width: level.width});\n        });\n        return res;\n    }\n    function get_level(level){\n        var levels = hls.levels||[];\n        level = level||hls.currentLevel;\n        return {\n            // level 0 is dummy for 'Auto' option in jwplayer's UI\n            jw: hls.manual_level==-1 || levels.length<2 ? 0 : level+1,\n            real: levels.length<2 ? 0 : level+1,\n        };\n    }\n    hls.on(Hls.Events.ERROR, function(event, data){\n        if (!data.fatal)\n            return;\n        var msg;\n        switch (data.details)\n        {\n        case Hls.ErrorDetails.MANIFEST_LOAD_ERROR:\n        case Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n            msg = 'Cannot load M3U8: '+data.response.statusText;\n            break;\n        default:\n            msg = 'Error loading media: '+data.details;\n            break;\n        }\n        _this.trigger(jwe.JWPLAYER_MEDIA_ERROR, {message: msg});\n    });\n    hls.on(Hls.Events.MANIFEST_LOADED, function(){\n        _this.trigger(jwe.JWPLAYER_MEDIA_LEVELS, {\n            currentQuality: get_level().jw,\n            levels: get_levels()\n        });\n    });\n    hls.on(Hls.Events.LEVEL_SWITCHED, function(e, data){\n        var levels = get_levels(), level_id = get_level(data.level);\n        _this.trigger(jwe.JWPLAYER_MEDIA_LEVEL_CHANGED, {\n            currentQuality: level_id.jw,\n            levels: levels,\n        });\n        var level = levels[level_id.real];\n        visual_quality.level = level;\n        visual_quality.level.index = level_id.real;\n        visual_quality.level.label = hls.manual_level==-1 && levels.length>1 ?\n            'auto' : level.label;\n        visual_quality.reason = visual_quality.reason||'auto';\n        _this.trigger('visualQuality', visual_quality);\n        visual_quality.reason = '';\n    });\n    this.init = function(item){\n        try_play = false;\n        video.setAttribute('jw-loaded', 'init');\n    };\n    this.load = function(item){\n        if (!this.attached)\n            return;\n        var newsource = get_default_src(item.sources).file;\n        var video_state = video.getAttribute('jw-loaded');\n        var hq = this.hls_queued, played = video.hasAttribute('jw-played');\n        if (!_is_mobile || played)\n        {\n            // don't change state on mobile before user initiates playback\n            this.setState('loading');\n        }\n        hq.seek = Math.max(item.starttime-(hq.rw_sec||0), 0);\n        if (this.hls_state!='ready' || (this.source||'') != newsource ||\n            ['init', 'started'].includes(video_state))\n        {\n            var sc;\n            try_play = false;\n            video.load();\n            hls.stopLoad(hls.media && this.hls_state=='ready' &&\n                video_state=='init');\n            hls_load(this.source = newsource);\n            video.setAttribute('jw-loaded', 'init');\n        }\n        else\n            hls_play();\n        if (_is_mobile && !played)\n        {\n            if (!try_play && (!_is_mobile.is_ios || can_play))\n            {\n                try_play = true;\n                can_play = false;\n                video_play();\n            }\n            if (!video.paused && this.state!='playing')\n                this.setState('loading');\n        }\n    };\n    this.play = function(){ hls_play(); };\n    this.pause = function(){\n        video.pause();\n        _this.setState('paused');\n    };\n    this.stop = function(){\n        hls.stopLoad();\n        _this.setState('idle');\n    };\n    this.volume = function(vol){ video.volume = Math.min(vol/100, 1.0); };\n    this.mute = function(state){ video.muted = !!state; };\n    this.seek = function(pos){\n        this._in_seek = true;\n        if (this.hls_state=='ready')\n        {\n            var sv = video.currentTime;\n            video.currentTime = pos;\n            this.trigger(jwe.JWPLAYER_MEDIA_SEEK, {position: sv, offset: pos});\n        }\n        else\n            this.hls_queued.seek = pos;\n    };\n    // XXX arik: todo, without it video resize will be wrong.\n    // eg. http://www.ozee.com/shows/muddha-mandaram#hola_mode=cdn&hola_zone=ozee_hap\n    this.resize = function(width, height, stretching){};\n    this.remove = function(){\n        hls.stopLoad();\n        this.source = undefined;\n        if (container === video.parentNode)\n            container.removeChild(video);\n    };\n    this.destroy = function(){\n        for (var e in video_listeners)\n            video.removeEventListener(e, video_listeners[e], false);\n        this.removeAllListeners();\n    };\n    this.setVisibility = function(state){\n        container.style.visibility = state ? 'visible' : '';\n        container.style.opacity = state ? 1 : 0;\n    };\n    this.setFullscreen = function(){ return false; };\n    this.getFullscreen = empty_fn('getFullscreen');\n    this.getContainer = function(){ return container; };\n    this.setContainer = function(element){\n        container = element;\n        if (this.video.parentNode !== element) {\n            container.appendChild(video);\n        }\n    };\n    hls.manual_level = -1;\n    this.setCurrentQuality = function(level){\n        if (level == hls.manual_level+1)\n            return;\n        hls.manual_level = level-1;\n        if (!hls.hola_adaptive)\n            hls.loadLevel = hls.manual_level;\n        _this.trigger(jwe.JWPLAYER_MEDIA_LEVEL_CHANGED,\n            {currentQuality: level, levels: get_levels()});\n        visual_quality.reason = 'api';\n    };\n    this.getName = function(){ return {name: 'hola/hls'}; };\n    this.get_position = function(){ return video.currentTime; };\n    this.getQualityLevels = function(){ return get_levels(); };\n    this.getCurrentQuality = function(){ return get_level(hls.loadLevel).jw; };\n    this.getAudioTracks = empty_fn('getAudioTracks');\n    this.getCurrentAudioTrack = empty_fn('getCurrentAudioTrack');\n    this.setCurrentAudioTrack = empty_fn('setCurrentAudioTrack');\n    this.checkComplete = function(){ return !!this.before_complete; };\n    this.setControls = empty_fn('setControls');\n    this.attachMedia = function(){\n        if (this.before_complete)\n            return playback_complete();\n        if (this.ad_count)\n            hls_log('jwprovider attach inside ad '+this.ad_count);\n        this.attached = true;\n        hls.attachMedia(video);\n    };\n    this.detachMedia = function(){\n        hls.trigger(Hls.Events.BUFFER_RESET);\n        hls.detachMedia();\n        if (this.level_cb)\n        {\n            hls.off(Hls.Events.LEVEL_LOADED, this.level_cb);\n            this.level_cb = undefined;\n        }\n        // XXX pavelki: hack to remove pending segments\n        if (hls.bufferController !== undefined) {\n            delete hls.bufferController.segments;\n        }\n        this.attached = false;\n        return video;\n    };\n    this.setState = function(state){\n        var oldState = this.state||'idle';\n        this.state = state;\n        if (state==oldState)\n            return;\n        this.trigger(jwe.JWPLAYER_PLAYER_STATE, {newstate: state});\n    };\n    this.sendMediaType = function(levels){\n        var is_audio = ['oga', 'aac', 'mp3', 'mpeg', 'vorbis']\n            .includes(levels[0].type);\n        this.trigger(jwe.JWPLAYER_MEDIA_TYPE, {mediaType: is_audio ?\n            'audio' : 'video'});\n    };\n}\n\nE.getName = function(){ return {name: 'hola/hls'}; };\n\n// XXX yurij: copied from zjwplayer3.js to not depend on our code\nfunction get_player_instances(){\n    var jwplayer = E.jwplayer||window.jwplayer;\n    var i = 0, res = [], jw;\n    // XXX marka/vadiml: a real instance will contain pause(), otherwise it\n    // will be {registerPlugin: ...} with anything the customer adds\n    while ((jw = jwplayer(i++)) && jw.pause)\n        res.push(jw);\n    return res;\n}\n\nfunction src_supported(src){\n    if (src.type=='hls')\n        return true;\n    return (src.file||'').match(/\\.m3u8$/);\n}\n\nE.supports = function(src){\n    var Hls = E.Hls||window.Hls;\n    var is_ad = get_player_instances().every(function(j){\n        // XXX yurij: jw.getPlaylist returns playlist item on early call\n        var pl = j.getPlaylist();\n        return (pl.every ? pl : [{sources: [pl]}]).every(function(p){\n            // XXX pavlo: playlist item can be w/o sources/allSources\n            return (p.allSources||p.sources||[{file: p.file}])\n                .every(function(s){ return s.file!=src.file; });\n        });\n    });\n    if (is_ad) // XXX yurij: we are not supporting adaptive ads\n        return false;\n    return !E.disabled && src_supported(src) && Hls && Hls.isSupported();\n};\n\nE.attach = function(){\n    var jwplayer = E.jwplayer||window.jwplayer;\n    E.disabled = false;\n    if (!provider_attached)\n    {\n        provider_attached = true;\n        // XXX arik: unregister on error/fallback\n        jwplayer.api.registerProvider(this);\n    }\n};\n\nE.detach = function(hp){\n    // we don't remove provider from list, just set it as disabled so it will\n    // return false in supports()\n    E.disabled = true;\n    if (!hp || !hp.attached)\n        return;\n    hp.setState('idle');\n    hp.detachMedia();\n};\n\n// XXX vadiml copied from loader.js&zjwplayer3.js to not depend on our code.\n// For use by HolaCDN Onboarding Tool extension\nE.reload_jwplayer_instances = function(){\n    get_player_instances().forEach(function(jw){\n        var c = jw.getConfig();\n        if (!c)\n            return;\n        // XXX marka: JW removes conf.advertising.client, try to restore it\n        if (c.advertising && !c.advertising.client && c.plugins)\n        {\n            for (var url in c.plugins)\n            {\n                if (c.plugins[url]!==c.advertising)\n                    continue;\n                var m = url.match(/\\/(\\w+)\\.js$/);\n                c.advertising.client = m && m[1];\n                break;\n            }\n        }\n        jw.setup(c);\n    });\n};\n\nE.VERSION = '0.0.79';\n"
  ]
}